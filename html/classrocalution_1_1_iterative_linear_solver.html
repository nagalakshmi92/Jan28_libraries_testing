<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>rocALUTION: rocalution::IterativeLinearSolver&lt; OperatorType, VectorType, ValueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rocm.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rocALUTION
   &#160;<span id="projectnumber">v1.3.4.0</span>
   </div>
   <div id="projectbrief">prototype interfaces compatible with ROCm platform and HiP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>rocalution</b></li><li class="navelem"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html">IterativeLinearSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">rocalution::IterativeLinearSolver&lt; OperatorType, VectorType, ValueType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__solver__module.html">Solver Module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for all linear iterative solvers.  
 <a href="classrocalution_1_1_iterative_linear_solver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="solver_8hpp_source.html">solver.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="classrocalution_1_1_solver.html">rocalution::Solver&lt; OperatorType, VectorType, ValueType &gt;</a>.</p>

<p>Inherited by <a class="el" href="classrocalution_1_1_base_multi_grid.html">rocalution::BaseMultiGrid&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_bi_c_g_stab.html">rocalution::BiCGStab&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_bi_c_g_stabl.html">rocalution::BiCGStabl&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_c_g.html">rocalution::CG&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_chebyshev.html">rocalution::Chebyshev&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_c_r.html">rocalution::CR&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_f_c_g.html">rocalution::FCG&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_f_g_m_r_e_s.html">rocalution::FGMRES&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_fixed_point.html">rocalution::FixedPoint&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_g_m_r_e_s.html">rocalution::GMRES&lt; OperatorType, VectorType, ValueType &gt;</a>, <a class="el" href="classrocalution_1_1_i_d_r.html">rocalution::IDR&lt; OperatorType, VectorType, ValueType &gt;</a>, and <a class="el" href="classrocalution_1_1_q_m_r_c_g_stab.html">rocalution::QMRCGStab&lt; OperatorType, VectorType, ValueType &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a8eebb0b187469ed92c675bd75e34b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a8eebb0b187469ed92c675bd75e34b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a2a8eebb0b187469ed92c675bd75e34b8">Init</a> (double abs_tol, double rel_tol, double div_tol, int max_iter)</td></tr>
<tr class="memdesc:a2a8eebb0b187469ed92c675bd75e34b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the solver with absolute/relative/divergence tolerance and maximum number of iterations. <br /></td></tr>
<tr class="separator:a2a8eebb0b187469ed92c675bd75e34b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6fb1aeaf491a1e4891dc13d4b893b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c6fb1aeaf491a1e4891dc13d4b893b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a0c6fb1aeaf491a1e4891dc13d4b893b2">Init</a> (double abs_tol, double rel_tol, double div_tol, int min_iter, int max_iter)</td></tr>
<tr class="memdesc:a0c6fb1aeaf491a1e4891dc13d4b893b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the solver with absolute/relative/divergence tolerance and minimum/maximum number of iterations. <br /></td></tr>
<tr class="separator:a0c6fb1aeaf491a1e4891dc13d4b893b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025c99dd56f7b09ebfd9df3905093c8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a025c99dd56f7b09ebfd9df3905093c8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a025c99dd56f7b09ebfd9df3905093c8e">InitMinIter</a> (int min_iter)</td></tr>
<tr class="memdesc:a025c99dd56f7b09ebfd9df3905093c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum number of iterations. <br /></td></tr>
<tr class="separator:a025c99dd56f7b09ebfd9df3905093c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b248faab2ff42e9106b6e38e5e0bbe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b248faab2ff42e9106b6e38e5e0bbe2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a3b248faab2ff42e9106b6e38e5e0bbe2">InitMaxIter</a> (int max_iter)</td></tr>
<tr class="memdesc:a3b248faab2ff42e9106b6e38e5e0bbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations. <br /></td></tr>
<tr class="separator:a3b248faab2ff42e9106b6e38e5e0bbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b570833a869738be46986d255b3c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05b570833a869738be46986d255b3c39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a05b570833a869738be46986d255b3c39">InitTol</a> (double abs, double rel, double div)</td></tr>
<tr class="memdesc:a05b570833a869738be46986d255b3c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the absolute/relative/divergence tolerance. <br /></td></tr>
<tr class="separator:a05b570833a869738be46986d255b3c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7610d7c31f7259f4365d79187cfa78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a9a7610d7c31f7259f4365d79187cfa78">SetResidualNorm</a> (int resnorm)</td></tr>
<tr class="memdesc:a9a7610d7c31f7259f4365d79187cfa78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the residual norm to \(L_1\), \(L_2\) or \(L_\infty\) norm.  <a href="#a9a7610d7c31f7259f4365d79187cfa78">More...</a><br /></td></tr>
<tr class="separator:a9a7610d7c31f7259f4365d79187cfa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5fd39c7f75f4339eaa41b67868653d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a5fd39c7f75f4339eaa41b67868653d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a0a5fd39c7f75f4339eaa41b67868653d">RecordResidualHistory</a> (void)</td></tr>
<tr class="memdesc:a0a5fd39c7f75f4339eaa41b67868653d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the residual history. <br /></td></tr>
<tr class="separator:a0a5fd39c7f75f4339eaa41b67868653d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0cce14cae0fdd8362bfad07eaf1ea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae0cce14cae0fdd8362bfad07eaf1ea4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#aae0cce14cae0fdd8362bfad07eaf1ea4">RecordHistory</a> (const std::string filename) const </td></tr>
<tr class="memdesc:aae0cce14cae0fdd8362bfad07eaf1ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the history to file. <br /></td></tr>
<tr class="separator:aae0cce14cae0fdd8362bfad07eaf1ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88dc520e41c9d1a2de5ad8c95e644c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac88dc520e41c9d1a2de5ad8c95e644c2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#ac88dc520e41c9d1a2de5ad8c95e644c2">Verbose</a> (int verb=1)</td></tr>
<tr class="memdesc:ac88dc520e41c9d1a2de5ad8c95e644c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the solver verbosity output. <br /></td></tr>
<tr class="separator:ac88dc520e41c9d1a2de5ad8c95e644c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8e806ae8a7776fa5306598afe7e076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c8e806ae8a7776fa5306598afe7e076"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a4c8e806ae8a7776fa5306598afe7e076">Solve</a> (const VectorType &amp;rhs, VectorType *x)</td></tr>
<tr class="memdesc:a4c8e806ae8a7776fa5306598afe7e076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve <a class="el" href="classrocalution_1_1_operator.html" title="Operator class. ">Operator</a> x = rhs. <br /></td></tr>
<tr class="separator:a4c8e806ae8a7776fa5306598afe7e076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a58d97330f7bf41d2ae116bc45f80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac40a58d97330f7bf41d2ae116bc45f80"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#ac40a58d97330f7bf41d2ae116bc45f80">SetPreconditioner</a> (<a class="el" href="classrocalution_1_1_solver.html">Solver</a>&lt; OperatorType, VectorType, ValueType &gt; &amp;precond)</td></tr>
<tr class="memdesc:ac40a58d97330f7bf41d2ae116bc45f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a preconditioner of the linear solver. <br /></td></tr>
<tr class="separator:ac40a58d97330f7bf41d2ae116bc45f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f70fb4d7ce86daa75b2796a0dc12044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f70fb4d7ce86daa75b2796a0dc12044"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a7f70fb4d7ce86daa75b2796a0dc12044">GetIterationCount</a> (void)</td></tr>
<tr class="memdesc:a7f70fb4d7ce86daa75b2796a0dc12044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the iteration count. <br /></td></tr>
<tr class="separator:a7f70fb4d7ce86daa75b2796a0dc12044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364ed49d060f8c24ba7af2398d1f54f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a364ed49d060f8c24ba7af2398d1f54f5"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a364ed49d060f8c24ba7af2398d1f54f5">GetCurrentResidual</a> (void)</td></tr>
<tr class="memdesc:a364ed49d060f8c24ba7af2398d1f54f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current residual. <br /></td></tr>
<tr class="separator:a364ed49d060f8c24ba7af2398d1f54f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814064201608ca980284fbea51792137"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a814064201608ca980284fbea51792137"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a814064201608ca980284fbea51792137">GetSolverStatus</a> (void)</td></tr>
<tr class="memdesc:a814064201608ca980284fbea51792137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current status. <br /></td></tr>
<tr class="separator:a814064201608ca980284fbea51792137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f2516ef96cebecbe83ba153bfacc8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20f2516ef96cebecbe83ba153bfacc8e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a20f2516ef96cebecbe83ba153bfacc8e">GetAmaxResidualIndex</a> (void)</td></tr>
<tr class="memdesc:a20f2516ef96cebecbe83ba153bfacc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return absolute maximum index of residual vector when using \(L_\infty\) norm. <br /></td></tr>
<tr class="separator:a20f2516ef96cebecbe83ba153bfacc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrocalution_1_1_solver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrocalution_1_1_solver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrocalution_1_1_solver.html">rocalution::Solver&lt; OperatorType, VectorType, ValueType &gt;</a></td></tr>
<tr class="memitem:a12765b63efe75bc88406a8d6ebb5aacc inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12765b63efe75bc88406a8d6ebb5aacc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a12765b63efe75bc88406a8d6ebb5aacc">SetOperator</a> (const OperatorType &amp;op)</td></tr>
<tr class="memdesc:a12765b63efe75bc88406a8d6ebb5aacc inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classrocalution_1_1_operator.html" title="Operator class. ">Operator</a> of the solver. <br /></td></tr>
<tr class="separator:a12765b63efe75bc88406a8d6ebb5aacc inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91354c5c116742c58d9eb2094cc6a68e inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91354c5c116742c58d9eb2094cc6a68e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a91354c5c116742c58d9eb2094cc6a68e">ResetOperator</a> (const OperatorType &amp;op)</td></tr>
<tr class="memdesc:a91354c5c116742c58d9eb2094cc6a68e inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the operator; see <a class="el" href="classrocalution_1_1_solver.html#acd20a051f0560a77645e35361df8f87c" title="Rebuild the solver only with numerical computation (no allocation or data structure computation) ...">ReBuildNumeric()</a> <br /></td></tr>
<tr class="separator:a91354c5c116742c58d9eb2094cc6a68e inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57992cfc687f3bf260964ad2fc19c467 inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57992cfc687f3bf260964ad2fc19c467"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a57992cfc687f3bf260964ad2fc19c467">Print</a> (void) const =0</td></tr>
<tr class="memdesc:a57992cfc687f3bf260964ad2fc19c467 inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information about the solver. <br /></td></tr>
<tr class="separator:a57992cfc687f3bf260964ad2fc19c467 inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034b434a4340a52430deed9b210e5003 inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a034b434a4340a52430deed9b210e5003"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a034b434a4340a52430deed9b210e5003">SolveZeroSol</a> (const VectorType &amp;rhs, VectorType *x)</td></tr>
<tr class="memdesc:a034b434a4340a52430deed9b210e5003 inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve <a class="el" href="classrocalution_1_1_operator.html" title="Operator class. ">Operator</a> x = rhs, setting initial x = 0. <br /></td></tr>
<tr class="separator:a034b434a4340a52430deed9b210e5003 inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8839d3ba527d75fedd29fdbe9bd651f inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8839d3ba527d75fedd29fdbe9bd651f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#aa8839d3ba527d75fedd29fdbe9bd651f">Clear</a> (void)</td></tr>
<tr class="memdesc:aa8839d3ba527d75fedd29fdbe9bd651f inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear (free all local data) the solver. <br /></td></tr>
<tr class="separator:aa8839d3ba527d75fedd29fdbe9bd651f inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84754d7422ad3fb35c17c61f0a609c7a inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84754d7422ad3fb35c17c61f0a609c7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a84754d7422ad3fb35c17c61f0a609c7a">Build</a> (void)</td></tr>
<tr class="memdesc:a84754d7422ad3fb35c17c61f0a609c7a inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the solver (data allocation, structure and numerical computation) <br /></td></tr>
<tr class="separator:a84754d7422ad3fb35c17c61f0a609c7a inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d11ee9943f785db285f0ef5c08c64eb inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d11ee9943f785db285f0ef5c08c64eb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a0d11ee9943f785db285f0ef5c08c64eb">BuildMoveToAcceleratorAsync</a> (void)</td></tr>
<tr class="memdesc:a0d11ee9943f785db285f0ef5c08c64eb inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the solver and move it to the accelerator asynchronously. <br /></td></tr>
<tr class="separator:a0d11ee9943f785db285f0ef5c08c64eb inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c2830a0ede8d82d1336aa25da6f907 inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17c2830a0ede8d82d1336aa25da6f907"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a17c2830a0ede8d82d1336aa25da6f907">Sync</a> (void)</td></tr>
<tr class="memdesc:a17c2830a0ede8d82d1336aa25da6f907 inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the solver. <br /></td></tr>
<tr class="separator:a17c2830a0ede8d82d1336aa25da6f907 inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd20a051f0560a77645e35361df8f87c inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd20a051f0560a77645e35361df8f87c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#acd20a051f0560a77645e35361df8f87c">ReBuildNumeric</a> (void)</td></tr>
<tr class="memdesc:acd20a051f0560a77645e35361df8f87c inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuild the solver only with numerical computation (no allocation or data structure computation) <br /></td></tr>
<tr class="separator:acd20a051f0560a77645e35361df8f87c inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c263e65898816f5838184c0af78a044 inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c263e65898816f5838184c0af78a044"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a3c263e65898816f5838184c0af78a044">MoveToHost</a> (void)</td></tr>
<tr class="memdesc:a3c263e65898816f5838184c0af78a044 inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all data (i.e. move the solver) to the host. <br /></td></tr>
<tr class="separator:a3c263e65898816f5838184c0af78a044 inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6410cd134c9ad00c1851d400cf0f8 inherit pub_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1b6410cd134c9ad00c1851d400cf0f8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#ab1b6410cd134c9ad00c1851d400cf0f8">MoveToAccelerator</a> (void)</td></tr>
<tr class="memdesc:ab1b6410cd134c9ad00c1851d400cf0f8 inherit pub_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all data (i.e. move the solver) to the accelerator. <br /></td></tr>
<tr class="separator:ab1b6410cd134c9ad00c1851d400cf0f8 inherit pub_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a35666e9af2a4abbc6d7e7be278a310e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35666e9af2a4abbc6d7e7be278a310e6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a35666e9af2a4abbc6d7e7be278a310e6">SolveNonPrecond_</a> (const VectorType &amp;rhs, VectorType *x)=0</td></tr>
<tr class="memdesc:a35666e9af2a4abbc6d7e7be278a310e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-preconditioner solution procedure. <br /></td></tr>
<tr class="separator:a35666e9af2a4abbc6d7e7be278a310e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb05c58ea0bf7443c039115dd27bfba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb05c58ea0bf7443c039115dd27bfba"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#adfb05c58ea0bf7443c039115dd27bfba">SolvePrecond_</a> (const VectorType &amp;rhs, VectorType *x)=0</td></tr>
<tr class="memdesc:adfb05c58ea0bf7443c039115dd27bfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioned solution procedure. <br /></td></tr>
<tr class="separator:adfb05c58ea0bf7443c039115dd27bfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c0602171dda0391e5574e0310504fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45c0602171dda0391e5574e0310504fb"></a>
ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a45c0602171dda0391e5574e0310504fb">Norm_</a> (const VectorType &amp;vec)</td></tr>
<tr class="memdesc:a45c0602171dda0391e5574e0310504fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vector norm. <br /></td></tr>
<tr class="separator:a45c0602171dda0391e5574e0310504fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrocalution_1_1_solver"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrocalution_1_1_solver')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrocalution_1_1_solver.html">rocalution::Solver&lt; OperatorType, VectorType, ValueType &gt;</a></td></tr>
<tr class="memitem:a9e6a5ceb6a8c35cd8d54ebff0664d27e inherit pro_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e6a5ceb6a8c35cd8d54ebff0664d27e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a9e6a5ceb6a8c35cd8d54ebff0664d27e">PrintStart_</a> (void) const =0</td></tr>
<tr class="memdesc:a9e6a5ceb6a8c35cd8d54ebff0664d27e inherit pro_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print starting message of the solver. <br /></td></tr>
<tr class="separator:a9e6a5ceb6a8c35cd8d54ebff0664d27e inherit pro_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2b6aec27eeaffbbd1130cc846c1019 inherit pro_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add2b6aec27eeaffbbd1130cc846c1019"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#add2b6aec27eeaffbbd1130cc846c1019">PrintEnd_</a> (void) const =0</td></tr>
<tr class="memdesc:add2b6aec27eeaffbbd1130cc846c1019 inherit pro_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print ending message of the solver. <br /></td></tr>
<tr class="separator:add2b6aec27eeaffbbd1130cc846c1019 inherit pro_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e8be1bd2107543c7390a81f8cee8cb inherit pro_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1e8be1bd2107543c7390a81f8cee8cb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#aa1e8be1bd2107543c7390a81f8cee8cb">MoveToHostLocalData_</a> (void)=0</td></tr>
<tr class="memdesc:aa1e8be1bd2107543c7390a81f8cee8cb inherit pro_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all local data to the host. <br /></td></tr>
<tr class="separator:aa1e8be1bd2107543c7390a81f8cee8cb inherit pro_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce29de0bdda9f35a6a687fd06ac9b11 inherit pro_methods_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ce29de0bdda9f35a6a687fd06ac9b11"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a8ce29de0bdda9f35a6a687fd06ac9b11">MoveToAcceleratorLocalData_</a> (void)=0</td></tr>
<tr class="memdesc:a8ce29de0bdda9f35a6a687fd06ac9b11 inherit pro_methods_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all local data to the accelerator. <br /></td></tr>
<tr class="separator:a8ce29de0bdda9f35a6a687fd06ac9b11 inherit pro_methods_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae811fa65d83729b92bb9573667162a4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae811fa65d83729b92bb9573667162a4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#ae811fa65d83729b92bb9573667162a4c">res_norm_</a></td></tr>
<tr class="memdesc:ae811fa65d83729b92bb9573667162a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Residual norm. <br /></td></tr>
<tr class="separator:ae811fa65d83729b92bb9573667162a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d12c17029094a3f46a0fa1ce491887"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30d12c17029094a3f46a0fa1ce491887"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a30d12c17029094a3f46a0fa1ce491887">index_</a></td></tr>
<tr class="memdesc:a30d12c17029094a3f46a0fa1ce491887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum index of residual vector when using \(L_\infty\). <br /></td></tr>
<tr class="separator:a30d12c17029094a3f46a0fa1ce491887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classrocalution_1_1_solver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classrocalution_1_1_solver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classrocalution_1_1_solver.html">rocalution::Solver&lt; OperatorType, VectorType, ValueType &gt;</a></td></tr>
<tr class="memitem:ad338b5f99cf339fb33218dd8b958cac4 inherit pro_attribs_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad338b5f99cf339fb33218dd8b958cac4"></a>
const OperatorType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#ad338b5f99cf339fb33218dd8b958cac4">op_</a></td></tr>
<tr class="memdesc:ad338b5f99cf339fb33218dd8b958cac4 inherit pro_attribs_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the operator. <br /></td></tr>
<tr class="separator:ad338b5f99cf339fb33218dd8b958cac4 inherit pro_attribs_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acdb829fa657a7b3e680d1ee6005c9b inherit pro_attribs_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2acdb829fa657a7b3e680d1ee6005c9b"></a>
<a class="el" href="classrocalution_1_1_solver.html">Solver</a>&lt; OperatorType, VectorType, ValueType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a2acdb829fa657a7b3e680d1ee6005c9b">precond_</a></td></tr>
<tr class="memdesc:a2acdb829fa657a7b3e680d1ee6005c9b inherit pro_attribs_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the defined preconditioner. <br /></td></tr>
<tr class="separator:a2acdb829fa657a7b3e680d1ee6005c9b inherit pro_attribs_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64924a0c87d60d2e4bf9fa295d0152cb inherit pro_attribs_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64924a0c87d60d2e4bf9fa295d0152cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a64924a0c87d60d2e4bf9fa295d0152cb">build_</a></td></tr>
<tr class="memdesc:a64924a0c87d60d2e4bf9fa295d0152cb inherit pro_attribs_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag == true after building the solver (e.g. <a class="el" href="classrocalution_1_1_solver.html#a84754d7422ad3fb35c17c61f0a609c7a" title="Build the solver (data allocation, structure and numerical computation) ">Build()</a>) <br /></td></tr>
<tr class="separator:a64924a0c87d60d2e4bf9fa295d0152cb inherit pro_attribs_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46ab4d19fba48ece463666d37a7dc86 inherit pro_attribs_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac46ab4d19fba48ece463666d37a7dc86"></a>
<a class="el" href="classrocalution_1_1_local_vector.html">LocalVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#ac46ab4d19fba48ece463666d37a7dc86">permutation_</a></td></tr>
<tr class="memdesc:ac46ab4d19fba48ece463666d37a7dc86 inherit pro_attribs_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutation vector (used if the solver performs permutation/re-ordering techniques) <br /></td></tr>
<tr class="separator:ac46ab4d19fba48ece463666d37a7dc86 inherit pro_attribs_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee162346e0d52543f9d3d25fe70ea8a inherit pro_attribs_classrocalution_1_1_solver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ee162346e0d52543f9d3d25fe70ea8a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrocalution_1_1_solver.html#a2ee162346e0d52543f9d3d25fe70ea8a">verb_</a></td></tr>
<tr class="memdesc:a2ee162346e0d52543f9d3d25fe70ea8a inherit pro_attribs_classrocalution_1_1_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbose flag. <br /></td></tr>
<tr class="separator:a2ee162346e0d52543f9d3d25fe70ea8a inherit pro_attribs_classrocalution_1_1_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class OperatorType, class VectorType, typename ValueType&gt;<br />
class rocalution::IterativeLinearSolver&lt; OperatorType, VectorType, ValueType &gt;</h3>

<p>Base class for all linear iterative solvers. </p>
<p>The iterative solvers are controlled by an iteration control object, which monitors the convergence properties of the solver, i.e. maximum number of iteration, relative tolerance, absolute tolerance and divergence tolerance. The iteration control can also record the residual history and store it in an ASCII file.</p><ul>
<li><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a2a8eebb0b187469ed92c675bd75e34b8" title="Initialize the solver with absolute/relative/divergence tolerance and maximum number of iterations...">Init()</a>, <a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a025c99dd56f7b09ebfd9df3905093c8e" title="Set the minimum number of iterations. ">InitMinIter()</a>, <a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a3b248faab2ff42e9106b6e38e5e0bbe2" title="Set the maximum number of iterations. ">InitMaxIter()</a> and <a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a05b570833a869738be46986d255b3c39" title="Set the absolute/relative/divergence tolerance. ">InitTol()</a> initialize the solver and set the stopping criteria.</li>
<li><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a0a5fd39c7f75f4339eaa41b67868653d" title="Record the residual history. ">RecordResidualHistory()</a> and <a class="el" href="classrocalution_1_1_iterative_linear_solver.html#aae0cce14cae0fdd8362bfad07eaf1ea4" title="Write the history to file. ">RecordHistory()</a> start the recording of the residual and write it into a file.</li>
<li><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#ac88dc520e41c9d1a2de5ad8c95e644c2" title="Set the solver verbosity output. ">Verbose()</a> sets the level of verbose output of the solver (0 - no output, 2 - detailed output, including residual and iteration information).</li>
<li><a class="el" href="classrocalution_1_1_iterative_linear_solver.html#ac40a58d97330f7bf41d2ae116bc45f80" title="Set a preconditioner of the linear solver. ">SetPreconditioner()</a> sets the preconditioning.</li>
</ul>
<p>All iterative solvers are controlled based on</p><ul>
<li>Absolute stopping criteria, when \(|r_{k}|_{L_{p}} \lt \epsilon_{abs}\)</li>
<li>Relative stopping criteria, when \(|r_{k}|_{L_{p}} / |r_{1}|_{L_{p}} \leq \epsilon_{rel}\)</li>
<li>Divergence stopping criteria, when \(|r_{k}|_{L_{p}} / |r_{1}|_{L_{p}} \geq \epsilon_{div}\)</li>
<li>Maximum number of iteration \(N\), when \(k = N\)</li>
</ul>
<p>where \(k\) is the current iteration, \(r_{k}\) the residual for the current iteration \(k\) (i.e. \(r_{k} = b - Ax_{k}\)) and \(r_{1}\) the starting residual (i.e. \(r_{1} = b - Ax_{init}\)). In addition, the minimum number of iterations \(M\) can be specified. In this case, the solver will not stop to iterate, before \(k \geq M\).</p>
<p>The \(L_{p}\) norm is used for the computation, where \(p\) could be 1, 2 and \(\infty\). The norm computation can be set with <a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a9a7610d7c31f7259f4365d79187cfa78" title="Set the residual norm to ,  or  norm. ">SetResidualNorm()</a> with 1 for \(L_{1}\), 2 for \(L_{2}\) and 3 for \(L_{\infty}\). For the computation with \(L_{\infty}\), the index of the maximum value can be obtained with <a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a20f2516ef96cebecbe83ba153bfacc8e" title="Return absolute maximum index of residual vector when using  norm. ">GetAmaxResidualIndex()</a>. If this function is called and \(L_{\infty}\) was not selected, this function will return -1.</p>
<p>The reached criteria can be obtained with <a class="el" href="classrocalution_1_1_iterative_linear_solver.html#a814064201608ca980284fbea51792137" title="Return the current status. ">GetSolverStatus()</a>, returning</p><ul>
<li>0, if no criteria has been reached yet</li>
<li>1, if absolute tolerance has been reached</li>
<li>2, if relative tolerance has been reached</li>
<li>3, if divergence tolerance has been reached</li>
<li>4, if maximum number of iteration has been reached</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OperatorType</td><td>- can be <a class="el" href="classrocalution_1_1_local_matrix.html" title="LocalMatrix class. ">LocalMatrix</a>, <a class="el" href="classrocalution_1_1_global_matrix.html" title="GlobalMatrix class. ">GlobalMatrix</a> or <a class="el" href="classrocalution_1_1_local_stencil.html" title="LocalStencil class. ">LocalStencil</a> </td></tr>
    <tr><td class="paramname">VectorType</td><td>- can be <a class="el" href="classrocalution_1_1_local_vector.html" title="LocalVector class. ">LocalVector</a> or <a class="el" href="classrocalution_1_1_global_vector.html" title="GlobalVector class. ">GlobalVector</a> </td></tr>
    <tr><td class="paramname">ValueType</td><td>- can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9a7610d7c31f7259f4365d79187cfa78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OperatorType , class VectorType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrocalution_1_1_iterative_linear_solver.html">rocalution::IterativeLinearSolver</a>&lt; OperatorType, VectorType, ValueType &gt;::SetResidualNorm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resnorm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the residual norm to \(L_1\), \(L_2\) or \(L_\infty\) norm. </p>
<ul>
<li>resnorm = 1 -&gt; \(L_1\) norm</li>
<li>resnorm = 2 -&gt; \(L_2\) norm</li>
<li>resnorm = 3 -&gt; \(L_\infty\) norm </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ROCm_Libraries/rocALUTION/src/solvers/<a class="el" href="solver_8hpp_source.html">solver.hpp</a></li>
<li>ROCm_Libraries/rocALUTION/src/solvers/solver.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
